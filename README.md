# Пробный вариант парсинга JOSE в web-приложении

Проект демонстрирует возможный вариант парсинга JOSE (JWS или JWE) с помощью кастомного HttpMessageConverter. 
Это позволит разместить логику по парсингу, проверке/формированию подписи, шифрованию/дешифрованию в едином месте, 
скрыть от прикладных разработчиков детали реализации и облегчить им жизнь, не вынуждая их каждый раз копипастить

## Постановка задачи со стороны бизнеса:

По умолчанию контроллеры для документов должны уметь работать с запросами в формате JSON или JWS. 
В настройках должен быть флаг "Необходимо шифрование", включающий обязательное шифрование запросов и ответов. 
При этом этот флаг должен действовать для одних эндпоинтов, а на другие не распространяться (это должно настраиваться на уровне кода).

Если флаг выключен, то:
* Разрешено принимать запросы и отвечать в формате JSON или JWS. 
  Форматы зависят от того, какие эндпоинты созданы для конкретно взятого документа и какие Content-Type и Accept заголовки
  настроены для этих эндпоинтов
* Везде запрещено использование формата JWE

Если флаг включен, то:
* Запрещено принимать запросы и отвечать в формате JSON или JWS (для эндпоинтов, на которые распространяется действие флага)
* Разрешено использование только формата JWE как в запросе, так и в ответе (для эндпоинтов, на которые распространяется действие флага), 
  при этом пользователь обязан указать в запросе заголовок Accept: application/jose и/или заголовок Content-Type: application/jose
* Для документов, на которые НЕ распространяется действие флага, как и обычно разрешено использование форматов JSON или JWS

## Решение:

В спринге для сериализации/десериализации Java-объектов в/из JSON/XML и т.д. при работе с HTTP-запросами используется механизм HttpMessageConverter'ов.
В спринге существует несколько дефолтных MessageConverter'ов. 
Например для сериализации/десериализации JSON обычно по умолчанию спрингом регистрируется MappingJackson2HttpMessageConverter.
Поэтому не будем изобретать костылей и решим задачу согласно правилам спринга. 
Воспользуемся этим механизмом: создадим кастомный HttpMessageConverter и зарегистрируем его для обработки формата application/jose.

Основная логика по сериализации/десериализации находится в JoseHttpMessageConverter. Также там делаются дополнительные проверки на случай,
если пользователь при включенном шифровании вместе с заголовком application/jose прислал в теле JWS вместо JWE. 
Или наоборот при выключенном шифровании вместе с заголовком application/jose прислал в теле JWE вместо JWS.

Флаг обязательности шифрования настраивается в application.properties в свойстве needTechEncryption.

* Если флаг needTechEncryption=true, то для всех методов контроллеров с аннотацией @JweRequired будет разрешен 
только формат JWE, остальные форматы запрещены.
На методы контроллеров без аннотации @JweRequired действие флага не распространяется (формат JWE им запрещен по умолчанию).

* Если флаг needTechEncryption=false, то для всех методов контроллеров запрещен формат JWE, разрешенность остальных форматов 
определяется стандартными средствами спринга, исходя из маппингов эндпоинтов в каждом конкретном контроллере.

Проверка на обязательность заголовков Accept = application/jose и Content-Type = application/jose находится в CustomHandlerInterceptor.
Проверка осущ-ся, если включено шифрование и на вызываемом методе контроллера есть аннотация @JweRequired 

В проекте есть два контроллера для двух разных документов. 
* JweDocumentController - контроллер для документа, на который распространяется флаг шифрования, т.е. возможна работа с документом, используя все форматы: JSON, JWS, JWE
* SimpleDocumentController - контроллер для документа, на который НЕ распространяется флаг шифрования, т.е. возможна работа с документом, используя только форматы JSON или JWS

Вызвать контроллеры можно, запуская тестовые HTTP-запросы из файлов test-jwe-document.http и test-simple-document.http

## Особенности реализации:
* Кастомный JoseHttpMessageConverter наследуется от MappingJackson2HttpMessageConverter, 
т.к. по сути JoseHttpMessageConverter всего лишь распаковывает или формирует JWS или JWE контейнер над JSON-payload,
а дальнейшая сериализация/десериализация в/из JSON передается в родительский MappingJackson2HttpMessageConverter.
Таким образом обработка самого JSON идёт один в один так же, как и при обычных HTTP-запросах с application/json форматом.
Но это не обязательно и можно отнаследовать JoseHttpMessageConverter например от AbstractHttpMessageConverter и самим реализовать
сериализацию/десериализацию в/из JSON, используя ObjectMapper.

## Преимущества:
* Вся логика по сериализации/десериализации в/из формат application/jose вынесена в кастомный JoseHttpMessageConverter,
т.е. исп-ся стандартный механизм спринга с HttpMessageConverter. 
Проверки присланных пользователем заголовков и тела, а также флага шифрования вынесены в единое место (почти), и эти проверки не нужно каждый раз копипастить.
* От сервисного слоя скрыта инф-ия о том, в каком формате приходит объект документа или в каком формате его нужно вернуть. 
Прикладному разработчику не нужно постоянно копипастить портянку из методов create, createFromJws, createFromJwe и т.д.
* Нет необходимости в слое с контроллерами реализовывать логику сериализации/десериализации в/из формат application/jose.
В контроллере необходимо лишь настроить необходимые для данного конкретного документа эндпоинты, используя маппинги с consumes и produces, 
и при необходимости указать аннотацию @JweRequired.   

## Недостатки:
* Т.к. JoseHttpMessageConverter отнаследован от MappingJackson2HttpMessageConverter, то в кач-ве payload может исп-ся
только JSON. Другие форматы, которые не сможет обработать MappingJackson2HttpMessageConverter, например XML, не поддерживаются.
Хотя тут возможно есть решение, нужно думать, т.к. JoseHttpMessageConverter не обязательно наследовать от MappingJackson2HttpMessageConverter, 
см. пункт "Особенности реализации"
* По-хорошему JoseHttpMessageConverter должен быть максимально простым и тупо сериализовать/десериализовать в/из JOSE (JWS или JWE) без каких-либо проверок,
без знания о флаге шифрования, без знания о том, что флаг распространяется не на все документы.
Но это не так, т.к. бизнес-постановка нетривиальна. Плюс накладывается тот факт, что RFC определяет всего лишь один MediaType application/jose,
 и под ним может скрываться как JWS, так и JWE 